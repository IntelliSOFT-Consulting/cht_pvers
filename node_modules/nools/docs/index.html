<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nools</title>
    <link rel="stylesheet" href="./assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="./assets/css/prettify.css">
    <style type="text/css">
        

/*.subnav-inner {*/
    /*width: 100%;*/
    /*height: 36px;*/
    /*background-color: #EEE;*/
    /*background-repeat: repeat-x;*/
    /*background-image: -moz-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, whiteSmoke), color-stop(100%, #EEE));*/
    /*background-image: -webkit-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -ms-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -o-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(startColorstr = '#f5f5f5', endColorstr = '#eeeeee', GradientType = 0);*/
    /*background-image: linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*-webkit-border-radius: 4px;*/
    /*-moz-border-radius: 4px;*/
    /*border-radius: 4px;*/
/*}*/

/*.subnav .nav > li > a:hover {*/
    /*color: black !important;*/
/*}*/

/*.subnav .nav li.dropdown .dropdown-toggle .caret,*/
/*.subnav .nav li.dropdown.open .caret {*/
    /*border-top-color: #999 !important;*/
    /*border-bottom-color: #999 !important;*/
/*}*/

/*.subnav-fixed {*/
    /*position: fixed;*/
    /*width : 90%;*/
    /*margin-right: auto;*/
    /*margin-left: auto;*/
    /*top: 40px;*/
    /*left: 0;*/
    /*right: 0;*/
    /*z-index: 1020;*/
    /*border-color: #D5D5D5;*/
    /*border-width: 0 0 1px;*/
    /*-webkit-border-radius: 0;*/
    /*-moz-border-radius: 0;*/
    /*border-radius: 0;*/
    /*-webkit-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*-moz-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);*/
/*}*/

/*.navbar .nav  .dropdown-menu {*/
    /*max-height: 500px;*/
    /*overflow: auto;*/
/*}â€‹*/

    </style>
    <style type="text/css">
        body {
            padding: 90px;
        }

        .subnav{
            margin-top: 40px;
            margin-right: auto;
            margin-left: auto;
            z-index: 1000;
        }

        .dropdown-menu{
            max-height: 500px;
            overflow-y: auto;
        }

        @media (max-width:979px) {
            .subnav{
                margin-top: auto;
            }
        }
    </style>
    <link rel="stylesheet" href="./assets/css/bootstrap-responsive.min.css">
    <script type="text/javascript">
        var init = (function () {
            "use strict";

            var processScroll = (function () {
                var curr = null, prev = null;
                return function (nav) {
                    var $win = $(window);
                    $('.subnav').each(function () {
                        var nav = $(this);
                        var navTop = $win.width() < 980 ? 0 : nav.offset().top - 40;

                        var scrollTop = $win.scrollTop();
                        if (scrollTop >= navTop && curr != nav) {
                            if(curr){
                                curr.removeClass('subnav-fixed')
                                prev = curr;
                            }
                            curr = nav;
                            curr.addClass('subnav-fixed')
                        } else if (curr == nav && scrollTop <= navTop) {
                            curr.removeClass('subnav-fixed');
                            prev.addClass('subnav-fixed');
                            curr = prev;
                        }else{
                            nav.removeClass('subnav-fixed');
                        }
                    });
                };
            })();

            return function () {
                window.prettyPrint && prettyPrint();
                $(".collapse").collapse();
                var $window = $(window);
                //$(".subnav").affix ();
                // fix sub nav on scroll
//                processScroll();
//                $(window).on('scroll', processScroll)
            }
        })();
    </script>
</head>
<body onload="init()">
<div class="navbar navbar-fixed-top navbar-inverse">
    <div class="navbar-inner">
        <div class="container">
            <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"> </span>
            </a>
            
            <a href="./index.html" class="brand">nools</a>
            
            <div class="nav-collapse">
                <ul class="nav">
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Docs<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
                            <li><a href="./examples.html">Examples</a></li>
                            
                            <li><a href="./history.html">Change Log</a></li>
                            
                        </ul>
                        

                        
                    
                </ul>
                
                <ul class="nav pull-right">

                    <li class="divider-vertical"></li>
                    <li><a href="https://github.com/C2FO/nools" target="#github" class="pull-right">github</a></li>
                </ul>
                
            </div>
        </div>
    </div>
</div>



<div class="container-fluid">
    <a name="top"></a>
    <div class="container">




  <h1 id="-deprecation-warning-"><em>Deprecation Warning</em></h1>
<p>C2FO is no longer maintaining this project. Please use accordingly. If you would like to help maintain or take over the project please let us know. </p>
<p><a href="https://travis-ci.org/C2FO/nools"><img src="https://travis-ci.org/C2FO/nools.png" alt="Build Status"></a></p>
<p><a href="https://ci.testling.com/C2FO/nools"><img src="https://ci.testling.com/C2FO/nools.png" alt="browser support"></a></p>
<h1 id="nools">Nools</h1>
<p><a href="https://gitter.im/C2FO/nools?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/C2FO/nools"></a></p>
<p>Nools is a <a href="http://en.wikipedia.org/wiki/Rete_algorithm">rete</a> based rules engine written entirely in javascript.</p>
<h1 id="installation">Installation</h1>
<pre class='prettyprint linenums lang-js'><code>npm install nools</code></pre>
<p>Or <a href="https://raw.github.com/C2FO/nools/master/nools.js">download the source</a> (<a href="https://raw.github.com/C2FO/nools/master/nools.min.js">minified</a>)</p>
<h1 id="usage">Usage</h1>
<ul>
<li>Flows<ul>
<li><a href="#flow">Defining A Flow</a></li>
<li><a href="#session">Sessions</a></li>
<li><a href="#facts">Facts</a><ul>
<li><a href="#facts-assert">Assert</a></li>
<li><a href="#facts-retract">Retract</a></li>
<li><a href="#facts-modify">Modify</a></li>
<li><a href="#get-facts">Retrieving Facts</a></li>
</ul>
</li>
<li><a href="#firing">Firing</a></li>
<li><a href="#disposing">Disposing</a></li>
<li><a href="#removing-flow">Removing A Flow</a></li>
<li><a href="#removing-flows">Removing All Flows</a></li>
<li><a href="#checking-for-flow">Checking If A Flow Exists</a></li>
<li><a href="#agenda-groups">Agenda Group</a><ul>
<li><a href="#agenda-groups-focus">Focus</a></li>
<li><a href="#agenda-groups-auto-focus">Auto Focus</a></li>
</ul>
</li>
<li><a href="#conflict-resolution">Conflict Resolution</a></li>
</ul>
</li>
<li><a href="#defining-rule">Defining Rules</a><ul>
<li><a href="#rule-structure">Structure</a></li>
<li><a href="#rule-salience">Salience</a></li>
<li><a href="#rule-scope">Scope</a></li>
<li><a href="#constraints">Constraints</a><ul>
<li><a href="#custom-contraints">Custom</a></li>
<li><a href="#not-constraint">Not</a></li>
<li><a href="#or-constraint">Or</a></li>
<li><a href="#from-constraint">From</a></li>
<li><a href="#exists-constraint">Exists</a></li>
</ul>
</li>
<li><a href="#action">Actions</a><ul>
<li><a href="#action-async">Async Actions</a></li>
</ul>
</li>
<li><a href="#globals">Globals</a></li>
<li><a href="#import">Import</a></li>
</ul>
</li>
<li><a href="#browser-support">Browser Support</a></li>
<li><a href="#fib">Fibonacci</a></li>
</ul>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://groups.google.com/forum/#!forum/nools">Nools Google group</a></li>
<li><a href="http://c2fo.github.io/nools/examples.html">Examples</a><ul>
<li><a href="http://c2fo.github.io/nools/examples/browser/conways_2d.html">Conways 2D</a></li>
<li><a href="http://c2fo.github.io/nools/examples/browser/conways_3d.html">Conways 3D</a></li>
<li><a href="http://c2fo.github.io/nools/examples/browser/sudoku.html">Sudoku</a></li>
<li><a href="http://c2fo.github.io/nools/examples/browser/fibonacci.html">Fibonacci</a></li>
<li><a href="http://c2fo.github.io/nools/examples/browser/manners.html">Miss Manners</a></li>
<li><a href="http://c2fo.github.io/nools/examples/browser/waltzDb.html">Waltz DB</a></li>
<li><a href="http://c2fo.github.io/nools/examples/browser/sendMoreMoney.html">Send More Money</a></li>
<li><a href="http://c2fo.github.io/nools/examples/browser/diagnose.html">Diagnosis</a></li>
</ul>
</li>
<li><a href="https://github.com/C2FO/nools/tree/master/test">Tests</a></li>
</ul>
<p><a name="flow"></a></p>
<h2 id="defining-a-flow">Defining a flow</h2>
<p>When using nools you define a <strong>flow</strong> which acts as a container for rules that can later be used to get
a <strong>session</strong></p>
<h3 id="programmatically">Programmatically</h3>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var nools = require(&quot;nools&quot;);

var Message = function (message) {
    this.text = message;
};

var flow = nools.flow(&quot;Hello World&quot;, function (flow) {

    //find any message that is exactly hello world
    flow.rule(&quot;Hello&quot;, [Message, &quot;m&quot;, &quot;m.text =~ /^hello\\sworld$/&quot;], function (facts) {
        facts.m.text = facts.m.text + &quot; goodbye&quot;;
        this.modify(facts.m);
    });

    //find all messages then end in goodbye
    flow.rule(&quot;Goodbye&quot;, [Message, &quot;m&quot;, &quot;m.text =~ /.*goodbye$/&quot;], function (facts) {
        console.log(facts.m.text);
    });
});</code></pre>
<p>In the above flow definition 2 rules were defined</p>
<ul>
<li>Hello<ul>
<li>Requires a Message</li>
<li>The messages&#39;s <code>text</code> must match the regular expression <code>/^hello\\sworld$/</code></li>
<li>When matched the message&#39;s <code>text</code> is modified and then we let the engine know that we modified the message.</li>
</ul>
</li>
<li>Goodbye<ul>
<li>Requires a Message</li>
<li>The messages&#39;s <code>text</code> must match the regular expression <code>/.*goodbye$/</code>(anything that ends in goodbye)</li>
<li>When matched the resulting message is logged.</li>
</ul>
</li>
</ul>
<h3 id="dsl">DSL</h3>
<p>You may also use the <code>nools</code> rules language to define your rules.</p>
<p>The following is the equivalent of the rules defined programmatically above.</p>
<pre class='prettyprint linenums lang-js'><code>define Message {
    text : &#39;&#39;,
    constructor : function(message){
        this.text = message;
    }
}

//find any message that starts with hello
rule Hello {
    when {
        m : Message m.text =~ /^hello(\s*world)?$/;
    }
    then {
        modify(m, function(){this.text += &quot; goodbye&quot;;});
    }
}

//find all messages then end in goodbye
rule Goodbye {
    when {
        m : Message m.text =~ /.*goodbye$/;
    }
    then {
        console.log(m.text);
    }
}</code></pre>
<p>To use the flow</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var flow = nools.compile(__dirname + &quot;/helloworld.nools&quot;),
    Message = flow.getDefined(&quot;message&quot;);</code></pre>
<h3 id="flow-events">Flow Events</h3>
<p>Each flow can have the following events emitted.</p>
<ul>
<li><code>assert (fact)</code> - emitted when facts are asserted</li>
<li><code>retract (fact)</code> - emitted when facts are retracted</li>
<li><code>modify (fact)</code> - emitted when facts are modified</li>
<li><code>fire (name, rule)</code> - emitted when an activation is fired.</li>
</ul>
<pre class='prettyprint linenums lang-js'><code>session.on(&quot;assert&quot;, function(fact){
    //fact was asserted
});

session.on(&quot;retract&quot;, function(fact){
    //fact was retracted
});

session.on(&quot;modify&quot;, function(fact){
    //fact was modifed
});

session.on(&quot;fire&quot;, function(name, rule){
    //a rule was fired.
});</code></pre>
<h3 id="-nools-compile-"><code>nools.compile</code></h3>
<p>The compile method accepts the following parameters</p>
<ul>
<li><code>source|path</code> - The first argument must either be a path that ends in <code>.nools</code> or a string which is the source of the rules that you wish to compile.</li>
<li><code>options?</code><ul>
<li><code>name</code> : This is the name of the flow. You can use this name to look up the flow by using <code>nools.getFlow</code>.</li>
<li><code>define</code> : A hash of Classes that should be aviable to the rules that you are compiling.</li>
<li><code>scope</code>: A hash of items that should be available to rules as they run. (i.e. a logger)</li>
</ul>
</li>
<li><code>cb?</code> - an options function to invoke when compiling is done.</li>
</ul>
<p><strong>Example</strong></p>
<pre class='prettyprint linenums lang-js'><code>rule &quot;person name is bob&quot; {
    when {
        p : Person p.name == &#39;bob&#39;;
    }
    then {
        logger.info(&quot;Found person with name of bob&quot;);
        retract(p);
    }
}</code></pre>
<p>In the above rules file we make use of a Person class and a logger. In order for nools to properly reference the Class and logger you must specify them in your options.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var flow = nools.compile(&quot;personFlow.nools&quot;, {
    define: {
        //The person class the flow should use
        Person: Person
    },
    scope: {
        //the logger you want your flow to use.
        logger: logger
    }
});</code></pre>
<p>You may also compile source directly.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var noolsSource = &quot;rule &#39;person name is bob&#39; {&quot;
    + &quot;   when {&quot;
    + &quot;     p : Person p.name == &#39;bob&#39;;&quot;
    + &quot;   }&quot;
    + &quot;   then {&quot;
    + &quot;       logger.info(&#39;Found person with name of bob&#39;);&quot;
    + &quot;       retract(p);&quot;
    + &quot;   }&quot;
    + &quot;}&quot;;

var flow = nools.compile(noolsSource, {
    define: {
        //The person class the flow should use
        Person: Person
    },
    scope: {
        //the logger you want your flow to use.
        logger: logger
    },
    name: &#39;person name is bob&#39;
});</code></pre>
<p><a name="session"></a></p>
<h2 id="working-with-a-session">Working with a session</h2>
<p>A session is an instance of the flow that contains a working memory and handles the assertion, modification, and retraction of facts from the engine.</p>
<p>To obtain an engine session from the flow invoke the  <code>getSession</code> method.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var session = flow.getSession();</code></pre>
<p><a name="facts"></a></p>
<h2 id="working-with-facts">Working with facts</h2>
<p>Facts are items that the rules should try to match.</p>
<p><a name="facts-assert"></a></p>
<h3 id="assert">Assert</h3>
<p>To add facts to the session use <code>assert</code> method.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">session.assert(new Message(&quot;hello&quot;));
session.assert(new Message(&quot;hello world&quot;));
session.assert(new Message(&quot;goodbye&quot;));</code></pre>
<p>As a convenience any object passed into <strong>getSession</strong> will also be asserted.</p>
<p><strong>Note</strong> assert is typically used pre engine execution and during the execution of the rules.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">flow.getSession(new Message(&quot;hello&quot;), new Message(&quot;hello world&quot;), new Message(&quot;goodbye&quot;));</code></pre>
<p><a name="facts-retract"></a></p>
<h3 id="retract">Retract</h3>
<p>To remove facts from the session use the <code>retract</code> method.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var m = new Message(&quot;hello&quot;);

//assert the fact into the engine
session.assert(m);

//remove the fact from the engine
session.retract(m);</code></pre>
<p><strong>Note</strong> <code>retract</code> is typically used during the execution of the rules.</p>
<p><a name="facts-modify"></a></p>
<h3 id="modify">Modify</h3>
<p>To modify a fact use the <code>modify</code> method.</p>
<p><strong>Note</strong> modify will not work with immutable objects (i.e. strings).</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
var m = new Message(&quot;hello&quot;);

session.assert(m);

m.text = &quot;hello goodbye&quot;;

session.modify(m);</code></pre>
<p><strong>Note</strong> <code>modify</code> is typically used during the execution of the rules.</p>
<p><a name="get-facts"></a></p>
<h3 id="retrieving-facts">Retrieving Facts</h3>
<p>To get a list of facts currently in the session you can use the <code>getFacts()</code> method exposed on a session.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">session.assert(1);
session.assert(&quot;A&quot;);
session.assert(&quot;B&quot;);
session.assert(2);

session.getFacts(); //[1, &quot;A&quot;, &quot;B&quot;, 2];</code></pre>
<p>You may also pass in a <code>Type</code> to <code>getFacts</code> which will return facts only of the given type.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">session.assert(1);
session.assert(&quot;A&quot;);
session.assert(&quot;B&quot;);
session.assert(2);

session.getFacts(Number); //[1, 2];
session.getFacts(String); //[&quot;A&quot;, &quot;B&quot;];</code></pre>
<p><a name="firing"></a></p>
<h2 id="firing-the-rules">Firing the rules</h2>
<p>When you get a session from a <strong>flow</strong> no rules will be fired until the <strong>match</strong> method is called.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var session = flow.getSession();
//assert your different messages
session.assert(new Message(&quot;goodbye&quot;));
session.assert(new Message(&quot;hello&quot;));
session.assert(new Message(&quot;hello world&quot;));

//now fire the rules
session.match(function(err){
    if(err){
        console.error(err.stack);
    }else{
        console.log(&quot;done&quot;);
    }
})</code></pre>
<p>The <strong>match</strong> method also returns a promise that is resolved once there are no more rules to activate.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">session.match().then(
  function(){
      console.log(&quot;Done&quot;);
  },
  function(err){
    //uh oh an error occurred
    console.error(err.stack);
  });</code></pre>
<h2 id="fire-until-halt">Fire until halt</h2>
<p>You may also run the engine an a &quot;reactive&quot; mode which will continue to match until <code>halt</code> is invoked.</p>
<p>In the following example the rules engine continues to evaluate until the counter reaches <code>10000</code>. If you remove the &quot;counted to high&quot; rule then the engine would run indefinitely.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
define Counter {
    count: 0,
    constructor: function(count){
        this.count = count;
    }
}

//We reached our goal
rule &quot;I can count!&quot; {
    when {
        $ctr: Counter $ctr.count == 10000;
    }
    then{
        console.log(&quot;Look ma! I counted to &quot; + $ctr.count);
        halt();
    }
}

//no counter was asserted so create one
rule &quot;not count&quot; {
    when {
        not($ctr: Counter);
    }
    then{
        console.log(&quot;Imma gonna count!&quot;);
        assert(new Counter(1));
    }
}

//A little status update
rule &quot;give them an update&quot; {
    when{
        $ctr: Counter $ctr.count % 1000 == 0 {count: $count}
    }
    then{
        console.log(&quot;Imma countin...&quot;);
        modify($ctr, function(){this.count = $count + 1;});
    }
}

//just counting away
rule count {
    when{
        $ctr: Counter {count: $count}
    }
    then{
        modify($ctr, function(){
          this.count = $count + 1;
        });
    }
}</code></pre>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">flow.getSession().matchUntilHalt(function(err){
    if(err){
        console.log(err.stack);
        return;
    }
    //halt finally invoked
});</code></pre>
<p><code>matchUntilHalt</code> also returns a promise.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">flow.getSession().matchUntilHalt()
    .then(
        function(){
            //all done!
        },
        function(err){
            console.log(err.stack);
        }
    );</code></pre>
<p><a name="disposing"></a></p>
<h2 id="disposing-of-the-session">Disposing of the session</h2>
<p>When working with a lot of facts it is wise to call the <code>dispose</code> method which will purge the current session of
all facts, this will help prevent the process from growing a large memory footprint.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">session.dispose();</code></pre>
<p><a name="removing-flow"></a></p>
<h1 id="removing-a-flow">Removing a flow</h1>
<p>To remove a defined flow from <code>nools</code> use the <code>deleteFlow</code> function.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var myFlow = nools.flow(&quot;flow&quot;);

nools.deleteFlow(&quot;flow&quot;); //returns nools for chaining

nools.getFlow(&quot;flow&quot;); //undefined</code></pre>
<p>You may also remove a flow using the <code>FlowContainer</code> object returned from nools.flow;</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var myFlow = nools.flow(&quot;flow&quot;);

nools.deleteFlow(myFlow); //returns nools for chaining

nools.getFlow(&quot;flow&quot;); //undefined</code></pre>
<p><a name="removing-flows"></a></p>
<h1 id="removing-all-flows">Removing All Flows</h1>
<p>To remove all flow from <code>nools</code> use the <code>deleteFlows</code> function.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var myFlow = nools.flow(&quot;flow&quot;);

nools.deleteFlows(); //returns nools for chaining

nools.getFlow(&quot;flow&quot;); //undefined</code></pre>
<p><a name="checking-for-flow"></a></p>
<h1 id="checking-if-a-flow-exists">Checking If A Flow Exists</h1>
<p>To check if a flow currently is registering with <code>nools</code> use the <code>hasFlow</code> function;</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var myFlow = nools.flow(&quot;flow&quot;);

nools.hasFlow(&quot;flow&quot;); //true</code></pre>
<p><a name="agenda-groups"></a></p>
<h2 id="agenda-groups">Agenda Groups</h2>
<p>Agenda groups allow for logical groups of rules within a flow.</p>
<p>The agenda manages a <code>stack</code> of <code>agenda-groups</code> that are currently in focus. The default <code>agenda-group</code> is called <code>main</code> and all rules that do not have an <code>agenda-group</code> specified are placed into the <code>main</code> <code>agenda-group</code>.</p>
<p>As rules are fired and a particular <code>agenda-group</code> runs out of activations then that <code>agenda-group</code> is popped from the internal <code>agenda-group</code> stack and the next one comes into focus. This continues until <code>focus</code> is explicitly called again or the <code>main</code> <code>agenda-group</code> comes into focus.</p>
<p><strong>Note</strong> Once an agenda group loses focus it must be re-added to the stack in order for those activations to be focused again.</p>
<p>To add a rule to an agenda-group you can use the <code>agendaGroup</code> option.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">this.rule(&quot;Hello World&quot;, {agendaGroup: &quot;ag1&quot;}, [Message, &quot;m&quot;, &quot;m.name == &#39;hello&#39;&quot;], function (facts) {
    this.modify(facts.m, function () {
        this.name = &quot;goodbye&quot;;
    });
});

this.rule(&quot;Hello World2&quot;, {agendaGroup: &quot;ag2&quot;}, [Message, &quot;m&quot;, &quot;m.name == &#39;hello&#39;&quot;], function (facts) {
    this.modify(facts.m, function () {
        this.name = &quot;goodbye&quot;;
    });
});</code></pre>
<p>Or in the dsl</p>
<pre class='prettyprint linenums lang-js'><code>rule &quot;Hello World&quot; {
    agenda-group: &quot;ag1&quot;;
    when{
        m : Message m.name === &#39;hello&#39;;
    }
    then{
        modify(m, function(){
            this.name = &quot;goodbye&quot;;
        });
    }
}
rule &quot;Hello World 2&quot; {
    agenda-group: &quot;ag2&quot;;
    when{
        m : Message m.name === &#39;goodbye&#39;;
    }
    then {
        modify(m, function(){
            m.name = &quot;hello&quot;;
        });
    }
}</code></pre>
<p>In the above rules we have defined two agenda-groups called <code>ag1</code> and <code>ag2</code></p>
<p><a name="agenda-groups-focus"></a></p>
<h3 id="focus">Focus</h3>
<p>When running your rules and you want a particular agenda group to run you must call <code>focus</code> on the session of the flow and specify the <code>agenda-group</code> to add to the stack.</p>
<pre class='prettyprint linenums lang-js'><code>//assuming a flow with the rules specified above.
var fired = [];
flow.getSession(new Message(&quot;hello&quot;))
    .focus(&quot;ag1&quot;)
    .on(&quot;fire&quot;, function (ruleName) {
        fired.push(ruleName);
    })
    .match(function () {
        console.log(fired);  //[ &#39;Hello World&#39; ]
    });</code></pre>
<p>Or you can add multiple <code>agenda-groups</code> to the focus stack.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var fired1 = [], fired2 = [];
flow
    .getSession(new Message(&quot;goodbye&quot;))
    .focus(&quot;ag1&quot;)
    .focus(&quot;ag2&quot;)
    .on(&quot;fire&quot;, function (ruleName) {
        fired1.push(ruleName);
    })
    .match(function () {
        console.log(&quot;Example 1&quot;, fired1); //[ &#39;Hello World&#39;, &#39;Hello World2&#39; ]
    });
flow
    .getSession(new Message(&quot;hello&quot;))
    .focus(&quot;ag2&quot;)
    .focus(&quot;ag1&quot;)
    .on(&quot;fire&quot;, function (ruleName) {
        fired3.push(ruleName);
    })
    .match(function () {
        console.log(&quot;Example 2&quot;, fired2); //[ &#39;Hello World&#39;, &#39;Hello World2&#39; ]
    });</code></pre>
<p>Notice above that the <strong>last</strong> <code>agenda-group</code> focused is added to the array first.</p>
<p><a name="agenda-groups-auto-focus"></a></p>
<h3 id="auto-focus">Auto Focus</h3>
<p>Sometimes you may want an <code>agenda-group</code> to <code>auto-focus</code> whenever a certain rule is activated.</p>
<pre class='prettyprint linenums lang-js'><code>this.rule(&quot;Bootstrap&quot;, [State, &quot;a&quot;, &quot;a.name == &#39;A&#39; &amp;&amp; a.state == &#39;NOT_RUN&#39;&quot;], function (facts) {
    this.modify(facts.a, function () {
        this.state = &#39;FINISHED&#39;;
    });
});

this.rule(&quot;A to B&quot;,
    [
        [State, &quot;a&quot;, &quot;a.name == &#39;A&#39; &amp;&amp; a.state == &#39;FINISHED&#39;&quot;],
        [State, &quot;b&quot;, &quot;b.name == &#39;B&#39; &amp;&amp; b.state == &#39;NOT_RUN&#39;&quot;]
    ],
    function (facts) {
        this.modify(facts.b, function () {
            this.state = &quot;FINISHED&quot;;
        });
    });

this.rule(&quot;B to C&quot;,
    {agendaGroup: &quot;B to C&quot;, autoFocus: true},
    [
        [State, &quot;b&quot;, &quot;b.name == &#39;B&#39; &amp;&amp; b.state == &#39;FINISHED&#39;&quot;],
        [State, &quot;c&quot;, &quot;c.name == &#39;C&#39; &amp;&amp; c.state == &#39;NOT_RUN&#39;&quot;]
    ],
    function (facts) {
        this.modify(facts.c, function () {
            this.state = &#39;FINISHED&#39;;
        });
        this.focus(&quot;B to D&quot;);
    });

this.rule(&quot;B to D&quot;,
    {agendaGroup: &quot;B to D&quot;},
    [
        [State, &quot;b&quot;, &quot;b.name == &#39;B&#39; &amp;&amp; b.state == &#39;FINISHED&#39;&quot;],
        [State, &quot;d&quot;, &quot;d.name == &#39;D&#39; &amp;&amp; d.state == &#39;NOT_RUN&#39;&quot;]
    ],
    function (facts) {
        this.modify(facts.d, function () {
        this.state = &#39;FINISHED&#39;;
    });
});</code></pre>
<p>Or using the dsl</p>
<pre class='prettyprint linenums lang-js'><code>rule Bootstrap {
    when{
        a : State a.name == &#39;A&#39; &amp;&amp; a.state == &#39;NOT_RUN&#39;;
    }
    then{
        modify(a, function(){
            this.state = &#39;FINISHED&#39;;
        });
    }
}


rule &#39;A to B&#39; {
    when{
        a : State a.name == &#39;A&#39; &amp;&amp; a.state == &#39;FINISHED&#39;;
        b : State b.name == &#39;B&#39; &amp;&amp; b.state == &#39;NOT_RUN&#39;;
    }
    then{
        modify(b, function(){
            this.state = &#39;FINISHED&#39;;
        });
    }
}

rule &#39;B to C&#39; {
    agenda-group: &#39;B to C&#39;;
    auto-focus: true;
    when{
        b: State b.name == &#39;B&#39; &amp;&amp; b.state == &#39;FINISHED&#39;;
        c : State c.name == &#39;C&#39; &amp;&amp; c.state == &#39;NOT_RUN&#39;;
    }
    then{
        modify(c, function(){
            this.state = &#39;FINISHED&#39;;
        });
        focus(&#39;B to D&#39;)
    }
}

rule &#39;B to D&#39; {
    agenda-group: &#39;B to D&#39;;
    when{
        b: State b.name == &#39;B&#39; &amp;&amp; b.state == &#39;FINISHED&#39;;
        d : State d.name == &#39;D&#39; &amp;&amp; d.state == &#39;NOT_RUN&#39;;
    }
    then{
        modify(d, function(){
            this.state = &#39;FINISHED&#39;;
        });
    }
}</code></pre>
<p>In the above rules we created a state machine that has a rule with <code>auto-focus</code> set to true.</p>
<p>This allows you to not have to specify <code>focus</code> when running the flow.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var fired = [];
flow
    .getSession(
        new State(&quot;A&quot;, &quot;NOT_RUN&quot;),
        new State(&quot;B&quot;, &quot;NOT_RUN&quot;),
        new State(&quot;C&quot;, &quot;NOT_RUN&quot;),
        new State(&quot;D&quot;, &quot;NOT_RUN&quot;)
    )
    .on(&quot;fire&quot;, function (name) {
        fired.push(name);
    })
    .match()
    .then(function () {
        console.log(fired); //[&quot;Bootstrap&quot;, &quot;A to B&quot;, &quot;B to C&quot;, &quot;B to D&quot;]
    });</code></pre>
<p><a name="conflict-resolution"></a></p>
<h2 id="conflict-resolution">Conflict Resolution</h2>
<p>When declaring a flow it is defined with a default conflict resolution strategy. A conflict resolution strategy is used to determine which rule to activate when multiple rules are ready to be activated at the same time.</p>
<h3 id="resolution-strategies">Resolution Strategies</h3>
<ul>
<li><code>salience</code> - sort activations on the specified <a href="#rule-salience"><code>salience</code></a>. (<strong>NOTE</strong> The default salience of a rule is 0).</li>
<li><code>activationRecency</code> - sort activations on activation recency. This is a <code>LIFO</code> strategy the latest activation takes precedence.</li>
<li><code>factRecency</code> - sort activations based on <code>fact</code> recency. Each time a fact is <code>asserted</code> or <code>modified</code> its recency is incremented.</li>
<li><code>bucketCounter</code> - sort activations on the internal <code>bucket</code> counter. The bucket counter is incremented after an activation is fired and the internal <code>workingMemory</code> is altered.</li>
</ul>
<p>The default conflict resolution strategy consists of <code>salience</code> and <code>activationRecency</code>.</p>
<h3 id="examples">Examples</h3>
<p><strong>Example 1</strong></p>
<pre class='prettyprint linenums lang-js'><code>//activation 1
{
    salience: 0,
    activationRecency: 1
}

//activation 2
{
    salience: 0,
    activationRecency: 2
}</code></pre>
<p>In the above example activation 2 would be fired since it is the most recent activation and the rule salience is the same.</p>
<p><strong>Example 2</strong></p>
<pre class='prettyprint linenums lang-js'><code>//activation 1
{
    salience: 1,
    activationRecency: 1
}

//activation 2
{
    salience: 0,
    activationRecency: 2
}</code></pre>
<p>In this example activation 1 would fire because it has a greater salience</p>
<h3 id="overidding-the-default-strategy">Overidding The Default Strategy</h3>
<p>To override the default strategy you can use the <code>conflictResolution</code> method on a flow.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
var flow = nools.flow(/**define your flow**/);

flow.conflictResolution([&quot;salience&quot;, &quot;factRecency&quot;, &quot;activationRecency&quot;]);</code></pre>
<p>The combination of <code>salience</code>, <code>factRecency</code>, and <code>activationRecency</code> would do the following.</p>
<ol>
<li>Check if the salience is the same, if not use the activation with the greatest salience.</li>
<li>If salience is the same check if fact recency is the same. The fact recency is determined by looping through the facts in each activation and until two different recencies are found. The activation with the greatest recency takes precendence.</li>
<li>If fact recency is the same check the activation recency.</li>
</ol>
<p><strong>Example 1</strong></p>
<pre class='prettyprint linenums lang-js'><code>//activation 1
{
    salience: 2,
    factRecency: [1,2,3],
    activationRecency: 1
}

//activation 2
{
    salience: 1,
    factRecency: [1,2,4],
    activationRecency: 2
}</code></pre>
<p>In this example activation 1 would fire because it&#39;s salience is the greatest.</p>
<p><strong>Example 2</strong></p>
<pre class='prettyprint linenums lang-js'><code>//activation 1
{
    salience: 1,
    factRecency: [1,2,3],
    activationRecency: 1
}

//activation 2
{
    salience: 1,
    factRecency: [1,2,4],
    activationRecency: 2
}</code></pre>
<p>In Example 2 activation 2 would fire because of the third recency entry.</p>
<p><strong>Example 3</strong></p>
<pre class='prettyprint linenums lang-js'><code>//activation 1
{
    salience: 2,
    factRecency: [1,2,3],
    activationRecency: 1
}

//activation 2
{
    salience: 1,
    factRecency: [1,2,3],
    activationRecency: 2
}</code></pre>
<p>In Example 3 activation 2 would fire because <code>salience</code> and <code>factRecency</code> are the same but activation 2&#39;s activation recency is greater.</p>
<p><a name="defining-rule"></a></p>
<h1 id="defining-rules">Defining rules</h1>
<p><a name="rule structure"></a></p>
<h2 id="rule-structure">Rule structure</h2>
<p>Lets look at the &quot;Calculate&quot; rule in the <a href="#fib">Fibonacci</a> example</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">   //flow.rule(type[String|Function], constraints[Array|Array[[]]], action[Function]);
   flow.rule(&quot;Calculate&quot;, [
         //Type     alias  pattern           store sequence to s1
        [Fibonacci, &quot;f1&quot;,  &quot;f1.value != -1&quot;, {sequence:&quot;s1&quot;}],
        [Fibonacci, &quot;f2&quot;, &quot;f2.value != -1 &amp;&amp; f2.sequence == s1 + 1&quot;, {sequence:&quot;s2&quot;}],
        [Fibonacci, &quot;f3&quot;, &quot;f3.value == -1 &amp;&amp; f3.sequence == s2 + 1&quot;],
        [Result, &quot;r&quot;]
    ], function (facts) {
        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;
        var v = f3.value = f1.value + facts.f2.value;
        facts.r.result = v;
        this.modify(f3);
        this.retract(f1);
    });</code></pre>
<p>Or using the nools DSL</p>
<pre class='prettyprint linenums lang-js'><code>rule Calculate{
    when {
        f1 : Fibonacci f1.value != -1 {sequence:s1};
        f2 : Fibonacci f2.value != -1 &amp;&amp; f2.sequence == s1 + 1 {sequence:s2};
        f3 : Fibonacci f3.value == -1 &amp;&amp; f3.sequence == s2 + 1;
    }
    then {
       modify(f3, function(){
            this.value = f1.value + f2.value;
       });
       retract(f1);
    }
}</code></pre>
<p><a name="rule-salience"></a></p>
<h3 id="salience">Salience</h3>
<p>Salience is an option that can be specified on a rule giving it a priority and allowing the developer some control over conflict resolution of activations.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">this.rule(&quot;Hello4&quot;, {salience: 7}, [Message, &quot;m&quot;, &quot;m.name == &#39;Hello&#39;&quot;], function (facts) {
});

this.rule(&quot;Hello3&quot;, {salience: 8}, [Message, &quot;m&quot;, &quot;m.name == &#39;Hello&#39;&quot;], function (facts) {
});

this.rule(&quot;Hello2&quot;, {salience: 9}, [Message, &quot;m&quot;, &quot;m.name == &#39;Hello&#39;&quot;], function (facts) {
});

this.rule(&quot;Hello1&quot;, {salience: 10}, [Message, &quot;m&quot;, &quot;m.name == &#39;Hello&#39;&quot;], function (facts) {
});</code></pre>
<p>Or using the DSL</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">rule Hello4 {
    salience: 7;
    when {
        m: Message m.name == &#39;hello&#39;;
    }
    then {}
}

rule Hello3 {
    salience: 8;
    when {
        m: Message m.name == &#39;hello&#39;;
    }
    then {}
}

rule Hello2 {
    salience: 9;
    when {
        m: Message m.name == &#39;hello&#39;;
    }
    then {}
}

rule Hello1 {
    salience: 10;
    when {
        m: Message m.name == &#39;hello&#39;;
    }
    then {}
}</code></pre>
<p>In the above flow we define four rules each with a different salience, when a single message is asserted they will fire in order of salience (highest to lowest).</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var fired = [];
flow1
    .getSession(new Message(&quot;Hello&quot;))
    .on(&quot;fire&quot;, function (name) {
        fired.push(name);
    })
    .match()
    .then(function(){
        console.log(fired); //[&quot;Hello1&quot;, &quot;Hello2&quot;, &quot;Hello3&quot;, &quot;Hello4&quot;]
    });</code></pre>
<p><a name="rule-scope"></a></p>
<h3 id="scope">Scope</h3>
<p>Scope allows you to access function from within your rules.</p>
<p>If you are using vanilla JS you can use the <code>scope</code> option when defining your rule.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
this.rule(&quot;hello rule&quot;, {scope: {isEqualTo: isEqualTo}},
   [
      [&quot;or&quot;,
         [String, &quot;s&quot;, &quot;isEqualTo(s, &#39;hello&#39;)&quot;],
         [String, &quot;s&quot;, &quot;isEqualTo(s, &#39;world&#39;)&quot;]
      ],
      [Count, &quot;called&quot;, null]
   ],
   function (facts) {
      facts.called.called++;
   });</code></pre>
<p>If you are using the dsl.</p>
<pre class='prettyprint linenums lang-js'><code>function matches(str, regex){
    return regex.test(str);
}

rule Hello {
    when {
        m : Message matches(m.text, /^hello\s*world)?$/);
    }
    then {
        modify(m, function(){
            this.text += &quot; goodbye&quot;;
        })
    }
}

rule Goodbye {
    when {
        m : Message matches(m.text, /.*goodbye$/);
    }
    then {
    }
}</code></pre>
<p>Or you can pass in a custom function using the scope option in compile.</p>
<pre class='prettyprint linenums lang-js'><code>rule Hello {
    when {
        m : Message doesMatch(m.text, /^hello\sworld$/);
    }
    then {
        modify(m, function(){
            this.text += &quot; goodbye&quot;;
        })
    }
}

rule Goodbye {
    when {
        m : Message doesMatch(m.text, /.*goodbye$/);
    }
    then {
    }
}</code></pre>
<p>Provided the <code>doesMatch</code> function in the scope option of compile.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">function matches(str, regex) {
   return regex.test(str);
};
var flow = nools.compile(__dirname + &quot;/rules/provided-scope.nools&quot;, {scope: {doesMatch: matches}});</code></pre>
<p><a name="constraints"></a></p>
<h3 id="constraints">Constraints</h3>
<p>Constraints define what facts the rule should match. The constraint is a array of either a single constraint (i.e. Bootstrap rule) or an array of constraints(i.e. Calculate).</p>
<p>Programmatically</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">[
   //Type     alias  pattern           store sequence to s1
  [Fibonacci, &quot;f1&quot;, &quot;f1.value != -1&quot;, {sequence:&quot;s1&quot;}],
  [Fibonacci, &quot;f2&quot;, &quot;f2.value != -1 &amp;&amp; f2.sequence == s1 + 1&quot;, {sequence:&quot;s2&quot;}],
  [Fibonacci, &quot;f3&quot;, &quot;f3.value == -1 &amp;&amp; f3.sequence == s2 + 1&quot;],
  [Result, &quot;r&quot;]
]</code></pre>
<p>Using nools DSL</p>
<pre class='prettyprint linenums lang-js'><code>when {
    f1 : Fibonacci f1.value != -1 {sequence:s1};
    f2 : Fibonacci f2.value != -1 &amp;&amp; f2.sequence == s1 + 1 {sequence:s2};
    f3 : Fibonacci f3.value == -1 &amp;&amp; f3.sequence == s2 + 1;
    r  : Result;
}</code></pre>
<ol>
<li>Type -  is the Object type the rule should match. The available types are<ul>
<li><code>String</code> - &quot;string&quot;, &quot;String&quot;, String</li>
<li><code>Number</code> - &quot;number&quot;, &quot;Number&quot;, Number</li>
<li><code>Boolean</code> - &quot;boolean&quot;, &quot;Boolean&quot;, Boolean</li>
<li><code>Date</code> - &quot;date&quot;, &quot;Date&quot;, Date</li>
<li><code>RegExp</code> - &quot;regexp&quot;, &quot;RegExp&quot;, RegExp</li>
<li><code>Array</code> - &quot;array&quot;, &quot;Array&quot;, [], Array</li>
<li><code>Object</code> - &quot;object&quot;, &quot;Object&quot;, &quot;hash&quot;, Object</li>
<li>Custom - any custom type that you define</li>
</ul>
</li>
<li>Alias - the name the object should be represented as.</li>
<li><p>Pattern(optional) - The pattern that should evaluate to a boolean, the alias that was used should be used to reference the object in the pattern. Strings should be in single quotes, regular expressions are allowed. Any previously defined alias/reference can be used within the pattern. Available operators are.</p>
<ul>
<li><code>&amp;&amp;</code>, <code>AND</code>, <code>and</code></li>
<li><code>||</code>, <code>OR</code>, <code>or</code></li>
<li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>gt</code>, <code>lt</code>, <code>gte</code>, <code>lte</code></li>
<li><code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>, <code>=~</code>, <code>!=~</code>, <code>eq</code>, <code>seq</code>, <code>neq</code>, <code>sneq</code>, <code>like</code>, <code>notLike</code></li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li><code>-</code> (unary minus)</li>
<li><code>.</code> (member operator)</li>
<li><code>in</code> (check inclusion in an array)</li>
<li><code>notIn</code> (check that something is not in an array)</li>
<li>Defined helper functions<ul>
<li><code>now</code> - the current date</li>
<li><code>Date(year?, month?, day?, hour?, minute?, second?, ms?)</code> - creates a new <code>Date</code> object</li>
<li><code>lengthOf(arr, length)</code> - checks the length of an array</li>
<li><code>isTrue(something)</code> - check if something === true</li>
<li><code>isFalse(something)</code> - check if something === false</li>
<li><code>isRegExp(something)</code> - check if something is a <code>RegExp</code></li>
<li><code>isArray(something)</code> - check if something is an <code>Array</code></li>
<li><code>isNumber(something)</code> - check if something is an <code>Number</code></li>
<li><code>isHash(something)</code> - check if something is strictly an <code>Object</code></li>
<li><code>isObject(something)</code> - check if something is any type of <code>Object</code></li>
<li><code>isDate(something)</code> - check if something is a <code>Date</code></li>
<li><code>isBoolean(something)</code> - check if something is a <code>Boolean</code></li>
<li><code>isString(something)</code> - check if something is a <code>String</code></li>
<li><code>isUndefined(something)</code> - check if something is a <code>undefined</code></li>
<li><code>isDefined(something)</code> - check if something is <code>Defined</code></li>
<li><code>isUndefinedOrNull(something)</code> - check if something is a <code>undefined</code> or <code>null</code></li>
<li><code>isPromiseLike(something)</code> - check if something is a &quot;promise&quot; like (containing <code>then</code>, <code>addCallback</code>, <code>addErrback</code>)</li>
<li><code>isFunction(something)</code> - check if something is a <code>Function</code></li>
<li><code>isNull(something)</code> - check if something is <code>null</code></li>
<li><code>isNotNull(something)</code> - check if something is not null</li>
<li><code>dateCmp(dt1, dt2)</code> - compares two dates return 1, -1, or 0</li>
<li><code>(years|months|days|hours|minutes|seconds)(Ago|FromNow)(interval)</code> - adds/subtracts the date unit from the current time</li>
</ul>
</li>
</ul>
</li>
<li><p>Reference(optional) - An object where the keys are properties on the current object, and values are aliases to use. The alias may be used in succeeding patterns.</p>
</li>
</ol>
<p><a name="custom-contraints"></a></p>
<h4 id="custom-constraint">Custom Constraint</h4>
<p>When declaring your rules progrmmatically you can also use a function as a constraint. The function will be called with an object containing each fact that has matched previous constraints.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var HelloFact = declare({
    instance: {
        value: true,
        constructor: function (value) {
            this.value = value;
        }
    }
});

var flow = nools.flow(&quot;custom contraint&quot;, function (flow) {
    flow.rule(&quot;hello rule&quot;, [HelloFact, &quot;h&quot;, function (facts) {
        return facts.h.value === true;
    }], function (facts) {
        console.log(facts.h.value); //always true
    });
});

var session = flow.getSession();
session.assert(new HelloFact(false));
session.assert(new HelloFact(true));
session.match().then(function(){
    console.log(&quot;DONE&quot;);
});</code></pre>
<p><a name="not-constraint"></a></p>
<h4 id="not-constraint">Not Constraint</h4>
<p>The <code>not</code> constraint allows you to check that particular <code>fact</code> does <strong>not</strong> exist.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
[
    [Number, &quot;n1&quot;],
    [&quot;not&quot;, Number, &quot;n2&quot;, &quot;n1 &gt; n2&quot;]
]</code></pre>
<p>Or using the DSL.</p>
<pre class='prettyprint linenums lang-js'><code>
when {
    n1: Number;
    not(n2: Number n1 &gt; n2);
}</code></pre>
<p>The previous example will check that for all numbers in the <code>workingMemory</code> there is <strong>not</strong> one that is greater than <code>n1</code>.</p>
<p><a name="or-constraint"></a></p>
<h4 id="or-constraint">Or Constraint</h4>
<p>The <code>or</code> constraint can be used to check for the existence of multiple facts.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
[
    [&quot;or&quot;,
        [String, &quot;s&quot;, &quot;s == &#39;hello&#39;&quot;],
        [String, &quot;s&quot;, &quot;s == &#39;world&#39;&quot;],
        [String, &quot;s&quot;, &quot;s == &#39;hello world&#39;&quot;]
    ]
]</code></pre>
<p>Using the DSL.</p>
<pre class='prettyprint linenums lang-js'><code>when {
    or(
        s : String s == &#39;hello&#39;,
        s : String s == &#39;world&#39;,
        s : String s == &#39;hello world&#39;
    );
}</code></pre>
<p>The previous example will evaluate to <code>true</code> if you have a string in <code>workingMemory</code> that equals <code>hello</code>, <code>world, or &#39;hello world</code>.</p>
<p><strong>Or with Not</strong></p>
<p>The <code>or</code> constraint can be combined with a <code>not</code> constraint to allow for the checking of multiple not conditions without the implcit and.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var flow = nools.flow(&quot;or condition with not conditions&quot;, function (flow) {
        flow.rule(&quot;hello rule&quot;, [
                [&quot;or&quot;,
                    [&quot;not&quot;, Number, &quot;n1&quot;, &quot;n1 == 1&quot;],
                    [&quot;not&quot;, String, &quot;s1&quot;, &quot;s1 == &#39;hello&#39;&quot;],
                    [&quot;not&quot;, Date, &quot;d1&quot;, &quot;d1.getDate() == now().getDate()&quot;]
                ],
                [Count, &quot;called&quot;, null]
            ], function (facts) {
                facts.called.called++;
            });
        });
});</code></pre>
<p>or using the dsl.</p>
<pre class='prettyprint linenums lang-js'><code>rule MultiNotOrRule {
    when {
        or (
            not(n1: Number n1 == 1),
            not(s1: String s1 == &#39;hello&#39;),
            not(d1: Date d1.getDate() == now().getDate())
        );
        c: Count;
    }
    then{
        c.called++;
    }
}</code></pre>
<p><strong>Note</strong> Using the <code>or</code> with a <code>not</code> will cause the activation to fire for each <code>not</code> condition that passes. In the above examples if none of the three facts existed then the rule would fire three times.</p>
<p><a name="from-constraint"></a></p>
<h4 id="from-constraint">From Constraint</h4>
<p>The <code>from</code> modifier allows for the checking of facts that are not necessarily in the <code>workingMemory</code>.</p>
<p>The <code>from</code> modifier can be used to access properties on a <code>fact</code> in <code>workingMemory</code> or you can use javascript expressions.</p>
<p>To access properties on a fact you can use the fact name and the property you wish to use as the source for the <code>from</code> source.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">[
    [Person, &quot;p&quot;],
    [Address, &quot;a&quot;, &quot;a.zipcode == 88847&quot;, &quot;from p.address&quot;],
    [String, &quot;first&quot;, &quot;first == &#39;bob&#39;&quot;, &quot;from p.firstName&quot;],
    [String, &quot;last&quot;, &quot;last == &#39;yukon&#39;&quot;, &quot;from p.lastName&quot;]
]</code></pre>
<p>Or using the DSL.</p>
<pre class='prettyprint linenums lang-js'><code>when {
    p: Person:
    a: Address a.zipcode == 88847 from p.address;
    first: String first == &#39;bob&#39; from p.firstName;
    last: String last == &#39;yukon&#39; from p.lastName;
}</code></pre>
<p>The above example will used the address, firstName and lastName from the <code>person</code> fact.</p>
<p>You can also use the <code>from</code> modifier to check facts that create a graph.</p>
<p>For example assume the person object from above has friends that are also of type <code>Person</code>.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">[
    [Person, &quot;p&quot;],
    [Person, &quot;friend&quot;, &quot;friend.firstName != p.firstName&quot;, &quot;from p.friends&quot;],
    [String, &quot;first&quot;, &quot;first =~ /^a/&quot;, &quot;from friend.firstName&quot;]
]</code></pre>
<p>Or using the DSL.</p>
<pre class='prettyprint linenums lang-js'><code>when {
    p: Person;
    friend: Person friend.firstName != p.firstName from p.friends;
    first: String first =~ /^a/ from friend.firstName;
}</code></pre>
<p>The above example will pull the <code>friend</code> fact from the friends array property on fact <code>p</code>, and first from the <code>friend</code>&#39;s <code>firstName</code>.</p>
<p>You could achieve the same thing using the following code if you assert all friends into working memory.</p>
<pre class='prettyprint linenums lang-js'><code>when {
    p: Person;
    friend: Person friend in p.friends &amp;&amp; friend.firstName != p.firstName &amp;&amp; p.firstName =~ /^a/;
}</code></pre>
<p>To specify the from source as an expression you can do the following.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">[
    [Number, &quot;n1&quot;, &quot;from [1,2,3,4,5]&quot;]
]</code></pre>
<p>Or using the dsl</p>
<pre class='prettyprint linenums lang-js'><code>{
    n1: Number from [1,2,3,4,5];
}</code></pre>
<p>Using the above syntax you could use <code>from</code> to bootstrap data.</p>
<p>You can also use any function defined in the scope of the <code>rule</code> or <code>flow</code></p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
flow.rule(&quot;my rule&quot;, {
    scope: {
        myArr: function(){
            return [1,2,3,4,5];
        }
    },
    [Number, &quot;n1&quot;, &quot;from myArr()&quot;],
    function(facts){
        this.assert(facts.n1);
    }
}</code></pre>
<p>Or using the dsl and the <a href="#rule-scope">scope</a> option.</p>
<pre class='prettyprint linenums lang-js'><code>rule &quot;my rule&quot;, {
    when {
        n1: Number from myArr();
    }
    then{
        assert(n1);
    }
}</code></pre>
<p><a name="exists-constraint"></a></p>
<h3 id="exists-constraint">Exists Constraint</h3>
<p><code>exists</code> is the logical inversion of a <code>not</code> constraint. It checks for the existence of a fact in memory.</p>
<p> <strong>NOTE</strong> If there are multiple facts that satisfy the constraint the rule will <strong>ONLY</strong> be fired once.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
 [
     [&quot;exists&quot;, Number, &quot;n1&quot;, &quot;n1 &gt; 1&quot;]
 ]</code></pre>
<p> Or using the DSL.</p>
<pre class='prettyprint linenums lang-js'><code>
 when {
     exists(n1: Number n1 &gt; 1);
 }</code></pre>
<p> Assuming the above constraint. The following facts would cause the rule to fire once since there is a number that is greater than 1.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript"> session.assert(1);
 session.assert(2);
 session.assert(3);
 session.assert(4);
 session.assert(5);</code></pre>
<p><a name="action"></a></p>
<h3 id="action">Action</h3>
<p>The action is a function that should be fired when all patterns in the rule match. The action is called in the scope
of the engine so you can use <code>this</code> to <code>assert</code>, <code>modify</code>, or <code>retract</code> facts. An object containing all facts and
references created by the alpha nodes is passed in as the first argument to the action.</p>
<p>So calculate&#39;s action modifies f3 by adding the value of f1 and f2 together and modifies f3 and retracts f1.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">function (facts) {
        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;
        var v = f3.value = f1.value + facts.f2.value;
        facts.r.result = v;
        this.modify(f3);
        this.retract(f1);
    }</code></pre>
<p>The session is also passed in as a second argument so alternatively you could do the following.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">function (facts, session) {
        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;
        var v = f3.value = f1.value + facts.f2.value;
        facts.r.result = v;
        session.modify(f3);
        session.retract(f1);
    }</code></pre>
<p>To define the actions with the nools DSL</p>
<pre class='prettyprint linenums lang-js'><code>then {
    modify(f3, function(){
        this.value = f1.value + f2.value;
    });
    retract(f1);
}</code></pre>
<p>For rules defined using the rules language nools will automatically determine what parameters need to be passed in based on what is referenced in the action.</p>
<p><a name="action-async"></a></p>
<h3 id="async-actions">Async Actions</h3>
<p>If your action is async you can use the third argument which should be called when the action is completed.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">function (facts, engine, next) {
        //some async action
        process.nextTick(function(){
            var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;
            var v = f3.value = f1.value + facts.f2.value;
            facts.r.result = v;
            engine.modify(f3);
            engine.retract(f1);
            next();
        });
    }</code></pre>
<p>If an error occurs you can pass the error as the first argument to <code>next</code>.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">then{
   saveToDatabase(user, function(err){
      next(new Error(&quot;Something went BOOM!&quot;));
   });
}</code></pre>
<p>If you are using a <a href="http://promises-aplus.github.io/promises-spec/"><code>Promises/A+</code></a> compliant library you can just return a promise from your action and <code>nools</code> will wait for the promise to resolve before continuing.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">then{
   return saveToDatabase(user); // assume saveToDatabase returns a promise
}</code></pre>
<p><a name="globals"></a></p>
<h3 id="globals">Globals</h3>
<p>Globals are accessible through the current working scope of rules defined in a <code>dsl</code>, very similar to using the <code>scope</code> option when compiling.</p>
<p><strong>Note</strong>  <code>globals</code> are not part of the working memory and therefore are not accessible in the LHS (when) or your rule.</p>
<p>Globals are used like the following:</p>
<pre class='prettyprint linenums lang-js'><code>global PI = Math.PI;
global SOME_STRING = &#39;some string&#39;;
global TRUE = true;
global NUM = 1.23;
global DATE = new Date();

rule &quot;A Rule&quot; {
    when {
        $obj: Object;
    }
    then{
        console.log(PI); //Math.PI;
        console.log(SOME_STRING); //&quot;some string&quot;
        console.log(TRUE); //true
        console.log(NUM); //1.23
        console.log(DATE); //Thu May 23 2013 15:49:22 GMT-0500 (CDT)
    }
}</code></pre>
<p>If you are using <code>nools</code> in <code>node</code> you can also use a require statement.</p>
<p><strong>NOTE</strong> require does not currently work for relative paths.</p>
<pre class='prettyprint linenums lang-js'><code>global util = require(&quot;util&quot;);

rule &quot;A Rule&quot; {
    when {
        $obj: Object;
    }
    then{
        util.log(&quot;HELLO WORLD&quot;);
    }
}</code></pre>
<p><a name="import"></a></p>
<h3 id="importing">Importing</h3>
<p>The <code>import</code> statement allows you to import other <code>nools</code> files into the current one. This can be used to split up logical flows into small reusable groups of rules.</p>
<p>Define our common model to be used across our flows.</p>
<pre class='prettyprint linenums lang-js'><code>//define.nools
define Count{
    constructor: function(){
        this.called = 0;
    }
}</code></pre>
<p>Create a rules file which imports the <code>define.nools</code> to define our <code>Count</code> model.</p>
<pre class='prettyprint linenums lang-js'><code>//orRule.nools

//import define.nools
import(&quot;./define.nools&quot;);
rule orRule {
    when {
        or(
            s : String s == &#39;hello&#39;,
            s : String s == &#39;world&#39;
        );
        count : Count;
    }
    then {
        count.called++;
        count.s = s;
    }
}</code></pre>
<p>Same as <code>orRule.nools</code> import our <code>define.nools</code></p>
<pre class='prettyprint linenums lang-js'><code>//notRule.nools
import(&quot;./defines.nools&quot;);
rule notRule {
    when {
        not(s : String s == &#39;hello&#39;);
        count : Count
    }
    then {
        count.called++;
    }
}</code></pre>
<p>Now we can use <code>orRule.nools</code> and <code>notRule.nools</code> to compose a new flow that contains <code>define.nools</code>, <code>orRule.nools</code> and <code>notRule.nools</code>.</p>
<p><strong>Note</strong> <code>nools</code> will handle duplicate imports, in this case <code>define.nools</code> will only be imported once.</p>
<pre class='prettyprint linenums lang-js'><code>//import
import(&quot;./orRules.nools&quot;);
import(&quot;./notRules.nools&quot;);</code></pre>
<h2 id="emitting-custom-events-">Emitting custom events.</h2>
<p>You may also emit events from your rule actions using the sessions emit function.</p>
<pre class='prettyprint linenums lang-js'><code>then {
    modify(f3, function(){
        this.value = f1.value + f2.value;
    });
    retract(f1);
    emit(&quot;my custom event&quot;);
}</code></pre>
<p>To listen to the event just use the on method of the session.</p>
<pre class='prettyprint linenums lang-js'><code>var session = flow.getSession();

session.on(&quot;my custom event&quot;, function(){
    //custom event called.
});</code></pre>
<h1 id="browser-support">Browser Support</h1>
<p><a name="browser-support"></a></p>
<p><code>Nools</code> can also be used in the browser. The only difference is that you cannot pass a file location to the compile method instead you must provide the source.</p>
<p>Nools is compatible with amd(requirejs) and can also be used in a standard script tag.</p>
<h3 id="example-1-">Example 1.</h3>
<p>In this example we compile rules definitions inlined in a script tag.</p>
<pre class='prettyprint linenums lang-js'><code class="lang-html">&lt;script type=&quot;text/javascript&quot; src=&quot;nools.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/nools&quot; id=&quot;simple&quot;&gt;
define Message {
    message : &quot;&quot;,
    constructor : function (message) {
        this.text = message;
    }
}

rule Hello {
    when {
        m : Message m.text =~ /^hello\sworld$/
    }
    then {
        modify(m, function(){
            this.text += &quot; goodbye&quot;;
        });
    }
}

rule Goodbye {
    when {
        m : Message m.text =~ /.*goodbye$/
    }
    then {
        document.getElementById(&quot;output&quot;).innerHTML += m.text + &quot;&lt;/br&gt;&quot;;
    }
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function init() {
       //get the source
       var source = document.getElementById(&quot;simple&quot;).innerHTML;
       //compile the source. The name option is required if compiling directly.
       var flow = nools.compile(source, {name: &quot;simple&quot;}),
                Message = flow.getDefined(&quot;message&quot;),
                session = flow.getSession();
        //assert your different messages
        session.assert(new Message(&quot;goodbye&quot;));
        session.assert(new Message(&quot;hello world&quot;));
        session.match();
    }
&lt;/script&gt;</code></pre>
<h3 id="using-a-compiled-dsl-">Using a compiled dsl.</h3>
<p>You may also use the <code>nools</code> executable to compile source into a browser friendly format skipping the need for compiling each time.</p>
<pre class='prettyprint linenums lang-js'><code>nools compile ./my/rules.nools &gt; ./compiled.js</code></pre>
<p>To use the flow require the compile version either through a script tag, <code>amd/requirejs</code>, or <code>commonjs</code> require.</p>
<p>If you import the flow using a script tag you can get a reference to the flow by using <code>nools.getFlow</code>.</p>
<pre class='prettyprint linenums lang-js'><code>nools.getFlow(&quot;rules&quot;);</code></pre>
<p>You may also specify the name of the flow when compiling, it defaults to the name of the nools file less &quot;.nools&quot;</p>
<pre class='prettyprint linenums lang-js'><code>nools compile -n &quot;my rules&quot; ./my/rules.nools</code></pre>
<pre class='prettyprint linenums lang-js'><code>nools.getFlow(&quot;my rules&quot;);</code></pre>
<p>If you are using requirejs or nools must be required using something other than <code>require(&quot;nools&quot;)</code> then you can specify a location of the nools source.</p>
<pre class='prettyprint linenums lang-js'><code>nools compile -nl &quot;./location/to/nools&quot; ./my/rules.nools</code></pre>
<h3 id="requirejs-examples">RequireJS examples</h3>
<p>Examples of using nools with require js are located in the <a href="./examples">examples directory</a>.</p>
<h1 id="examples">Examples</h1>
<p><a name="fib"></a></p>
<h2 id="fibonacci">Fibonacci</h2>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">&quot;use strict&quot;;

var nools = require(&quot;nools&quot;);

var Fibonacci = function (sequence, value) {
    this.sequence = sequence;
    this.value = value || -1;
};

var Result = function (result) {
    this.result = result || -1;
};


var flow = nools.flow(&quot;Fibonacci Flow&quot;, function (flow) {

    flow.rule(&quot;Recurse&quot;, [
        [&quot;not&quot;, Fibonacci, &quot;f&quot;, &quot;f.sequence == 1&quot;],
        [Fibonacci, &quot;f1&quot;, &quot;f1.sequence != 1&quot;]
    ], function (facts) {
        var f2 = new Fibonacci(facts.f1.sequence - 1);
        this.assert(f2);
    });

    flow.rule(&quot;Bootstrap&quot;, [
          Fibonacci, &quot;f&quot;, &quot;f.value == -1 &amp;&amp; (f.sequence == 1 || f.sequence == 2)&quot;
    ], function (facts) {
        var f = facts.f;
        f.value = 1;
        this.modify(f);
    });

    flow.rule(&quot;Calculate&quot;, [
        [Fibonacci, &quot;f1&quot;, &quot;f1.value != -1&quot;, {sequence:&quot;s1&quot;}],
        [Fibonacci, &quot;f2&quot;, &quot;f2.value != -1 &amp;&amp; f2.sequence == s1 + 1&quot;, {sequence:&quot;s2&quot;}],
        [Fibonacci, &quot;f3&quot;, &quot;f3.value == -1 &amp;&amp; f3.sequence == s2 + 1&quot;],
        [Result, &quot;r&quot;]
    ], function (facts) {
        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;
        var v = f3.value = f1.value + facts.f2.value;
        facts.r.result = v;
        this.modify(f3);
        this.retract(f1);
    });
});

var r1 = new Result(),
    session1 = flow.getSession(new Fibonacci(10), r1),
    s1 = new Date;
session1.match().then(function () {
    console.log(&quot;%d [%dms]&quot;, r1.result, new Date - s1);
    session1.dispose();
});

var r2 = new Result(),
    session2 = flow.getSession(new Fibonacci(150), r2),
    s2 = new Date;
session2.match().then(function () {
    console.log(&quot;%d [%dms]&quot;, r2.result, new Date - s2);
    session2.dispose();
});

var r3 = new Result(),
    session3 = flow.getSession(new Fibonacci(1000), r3),
    s3 = new Date;
session3.match().then(function () {
    console.log(&quot;%d [%dms]&quot;, r3.result, new Date - s3);
    session3.dispose();
});</code></pre>
<p>Output</p>
<pre class='prettyprint linenums lang-js'><code>55 [43ms]
9.969216677189305e+30 [383ms]
4.346655768693743e+208 [3580ms]</code></pre>
<h3 id="fibonacci-with-nools-dsl">Fibonacci with nools DSL</h3>
<pre class='prettyprint linenums lang-js'><code>//Define our object classes, you can
//also declare these outside of the nools
//file by passing them into the compile method
define Fibonacci {
    value:-1,
    sequence:null
}
define Result {
    value : -1
}

rule Recurse {
    when {
        //you can use not or or methods in here
        not(f : Fibonacci f.sequence == 1);
        //f1 is how you can reference the fact else where
        f1 : Fibonacci f1.sequence != 1;
    }
    then {
        assert(new Fibonacci({sequence : f1.sequence - 1}));
    }
}

rule Bootstrap {
   when {
       f : Fibonacci f.value == -1 &amp;&amp; (f.sequence == 1 || f.sequence == 2);
   }
   then{
       modify(f, function(){
           this.value = 1;
       });
   }
}

rule Calculate {
    when {
        f1 : Fibonacci f1.value != -1 {sequence : s1};
        //here we define constraints along with a hash so you can reference sequence
        //as s2 else where
        f2 : Fibonacci f2.value != -1 &amp;&amp; f2.sequence == s1 + 1 {sequence:s2};
        f3 : Fibonacci f3.value == -1 &amp;&amp; f3.sequence == s2 + 1;
        r : Result
    }
    then {
        modify(f3, function(){
            this.value = r.result = f1.value + f2.value;
        });
        retract(f1);
    }
}</code></pre>
<p>And to run</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var flow = nools.compile(__dirname + &quot;/fibonacci.nools&quot;);

var Fibonacci = flow.getDefined(&quot;fibonacci&quot;), Result = flow.getDefined(&quot;result&quot;);
var r1 = new Result(),
    session1 = flow.getSession(new Fibonacci({sequence:10}), r1),
    s1 = +(new Date());
session1.match().then(function () {
    console.log(&quot;%d [%dms]&quot;, r1.result, +(new Date()) - s1);
    session1.dispose();
});

var r2 = new Result(),
    session2 = flow.getSession(new Fibonacci({sequence:150}), r2),
    s2 = +(new Date());
session2.match().then(function () {
    console.log(&quot;%d [%dms]&quot;, r2.result, +(new Date()) - s2);
    session2.dispose();
});

var r3 = new Result(),
    session3 = flow.getSession(new Fibonacci({sequence:1000}), r3),
    s3 = +(new Date());
session3.match().then(function () {
    console.log(&quot;%d [%dms]&quot;, r3.result, +(new Date()) - s3);
    session3.dispose();
});</code></pre>
<h2 id="license">License</h2>
<p>MIT <a href="https://github.com/C2FO/nools/raw/master/LICENSE">https://github.com/C2FO/nools/raw/master/LICENSE</a></p>
<h2 id="meta">Meta</h2>
<ul>
<li>Code: <code>git clone git://github.com/C2FO/nools.git</code></li>
</ul>


<hr>

Documentation generated using <a href="https://github.com/doug-martin/coddoc">coddoc</a>.


</div>
</div>
<script type="text/javascript" src="./assets/js/jquery.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap.min.js"></script>
<script type="text/javascript" src="./assets/js/prettify.js"></script>

</body>
</html>

